---
title: "flat_minimal_package.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# General tools

## validate_rules

```{r function-validate_rules}
#' Validate domain knowing in a data.frame
#' 
#' This function if a wrappers from many utilities from the validate package.
#'
#' @param df A data.frame or data.table to perform the analysis.
#' @inheritParams validate::validator
#' @param env A list with all the variables we want to make available in the validation rules.
#' @param keep_rl_cols Defining the columns to keep all data.table of broken row level rules.
#' @param select_rl_rules Defining which row level rules to return as data.table in the row_level_errors element.
#'
#' @return
#' This function return a list of 2 elements:
#' - summary: Return data.table with the result of all checks.
#' - row_level_errors: Return a list of data.frames containing the column **Broken Rule**, the columns listed in the `keep_rl_cols` and the columns used to perform the validation.
#' 
#' @export
#'
#' @examples
validate_rules <- function(df,
                           ...,
                           env = list(),
                           keep_rl_cols = NULL,
                           select_rl_rules = NULL){
  
  ## Confirming class before continue
  if(data.table::is.data.table(df)){
    df = as.data.frame(df)
  }
  
  ## Making the validation
  confront_result =
    validate::confront(df,
                       x = validate::validator(...),
                       ref = env)
  
  
  ## Defining the table to explore
  summary_result = validate::summary(confront_result)
  
  ## We don't define name as key as
  ## Validate package really in the order
  ## to return the violations later
  data.table::setDT(summary_result)
  
  ## We cannot allow reporting NA as valid values
  na_rules = summary_result[nNA > 0, name]
  if(length(na_rules) > 0){
    
    stop(paste("The following rules are returning NA:", 
               paste0(na_rules, collapse = ", ")))
    
  }
  
  
  ## Defining the row level rules to extract
  
  if(!is.null(select_rl_rules)){
    
    valid_row_level_rules = summary_result[items == nrow(df), name]
    row_level_rules =  intersect(valid_row_level_rules, select_rl_rules)
    
    if(length(row_level_rules) == 0L){
      stop(paste("Please select a valid row rule:",
                 paste0(valid_row_level_rules, collapse = ", ")))
    } 
    
  }else{
    
    row_level_rules =  summary_result[items == nrow(df) & fails > 0, name]
    
  }
  
  
  ## If the is not more problems to check
  ## we can end the function here
  if(length(row_level_rules) == 0L){
    
    final_list = list(
      summary = summary_result[, !c("expression")],
      row_level_errors = NULL
    )
    
    return(final_list)
  }
  
  
  ## Creating a pattern to extract 
  ## any column listed in the original table
  col_pattern =
    c("!", "?", "\\", "(", ")", "{", 
      "}", "$", "^",  "+", "*", "|") |>
    paste0("\\", a = _) |>
    paste0(collapse = "|") |>
    stringr::str_replace_all(string = names(df), replacement = ".")  |>
    paste0(collapse = "|")
  
  
  ## Adding rule name as name before calling lapply to create the list
  data.table::setattr(row_level_rules, "names", row_level_rules)
  
  ## Creating a list with all cases to correct at row level
  row_level_errors =
    lapply(row_level_rules,
           df_used = df,
           pattern = col_pattern,
           confront_list = confront_result,
           summary_dt = summary_result,
           FUN = function(rule, df_used, pattern, confront_list, summary_dt){
      
      error_rows = validate::violating(df_used, confront_result[rule])
      
      data.table::setDT(error_rows)
      
      error_rows[, `Broken Rule` := rule]
      
      cols_to_keep =
        summary_dt[rule,
                   on = "name",
                   j = expression] |>
        stringr::str_extract_all(pattern = pattern) |>
        unlist() |>
        c("Broken Rule", keep_rl_cols, a = _) |>
        unique()
      
      return(error_rows[, .SD, .SDcols = cols_to_keep])
      
    })
  
  
  final_list = list(
    ## As we advance in complexity the expressions gets to hard to be read
    summary = summary_result[, !c("expression")],
    row_level_errors = row_level_errors
  )
  
  return(final_list)
  
}
```

### examples

```{r examples-validate_rules}
validation_list <- 
  data.table::as.data.table(mtcars, 
                            keep.rownames = "Car (Name)") |>
  validate_rules("mpg low" = mpg > min_mpg,
                 "hp high" = hp < 200,
                 env = list(min_mpg = 15),
                 keep_rl_cols = "Car (Name)")

names(validation_list)

validation_list$summary

validation_list$row_level_errors
```


### tests

```{r tests-validate_rules}
test_that("It reports problems at general level",{
  
  validation_list =
    validate_rules(mtcars,
                   # A satisfied rule
                   "cyl|num" = is.numeric(cyl),
                   # A broken rule
                   "mpg|string" = is.character(mpg))
  
  # It report the error
  expect_equal(validation_list$summary$fails, c(0L, 1L))
  
  # Don't fill the row level list
  expect_equal(validation_list$row_level_errors, NULL)
  
})


test_that("It reports problems at row level",{
  
  data_used = data.table::as.data.table(mtcars, 
                                        keep.rownames = "Car (Name)")
  
  validation_list = 
    validate_rules(data_used,
                   "mpg low" = mpg > min_mpg,
                   "hp high" = hp < 200,
                   env = list(min_mpg = 15),
                   keep_rl_cols = "Car (Name)")
  
  # It reporting all errors
  expect_equal(validation_list$summary$fails, c(6L, 7L))
  
  # It's selecting the correct columns
  expect_equal(names(validation_list$row_level_errors$`mpg.low`), 
               c("Broken Rule", "Car (Name)", "mpg"))
  expect_equal(names(validation_list$row_level_errors$`hp.high`), 
               c("Broken Rule", "Car (Name)", "hp"))
  
  # It's selecting the correct correct rows
  expect_equal(validation_list$row_level_errors$`mpg.low`$`Car (Name)`,
               data_used[!(mpg > 15), `Car (Name)`])
  expect_equal(validation_list$row_level_errors$`hp.high`$`Car (Name)`,
               data_used[!(hp < 200), `Car (Name)`])
  
})


test_that("We can select row rules to validate",{
  
  data_used = data.table::as.data.table(mtcars, 
                                        keep.rownames = "Car (Name)")
  
  validation_list = 
    validate_rules(data_used,
                   "mpg low" = mpg > min_mpg,
                   "hp high" = hp < 200,
                   env = list(min_mpg = 15),
                   keep_rl_cols = "Car (Name)",
                   select_rl_rules = "hp.high")
  
  # Select row level don't affect the summary
  expect_equal(validation_list$summary$fails, c(6L, 7L))
  
  # Only the defined row level rule must be in the list
  expect_equal(names(validation_list$row_level_errors), "hp.high")
  
  # It shows a useful message if error
  expect_error({
    validate_rules(data_used,
                   "mpg low" = mpg > min_mpg,
                   "hp high" = hp < 200,
                   env = list(min_mpg = 15),
                   keep_rl_cols = "Car (Name)",
                   select_rl_rules = "no.created.rule")
  },
  regexp = "^Please select a valid row rule")
  
})

```


## action_if_problem

```{r function-action_if_problem}
#' Stop the script if any problem found
#'
#' @param x A list containing the summary from [validate_rules()].
#' @param message_text The message to display when applying the action.
#' @param problem_action Select if you want to display warning or stop the code.
#'
#' @return The list passed as first argument.
#' @export
#' 
action_if_problem = function(x, 
                             message_text, 
                             problem_action = c("stop", "warning")){
  
  if(sum(x$summary$fails) != 0){
    
    action_fun = 
      match.arg(problem_action) |>
      switch ("stop" = stop,
              "warning" = warning)
    
    print(message_text)
    print(x$summary[fails != 0, ])
    action_fun(message_text)
  }
  
  invisible(x)

}

```

### examples

```{r examples-action_if_problem}

try({
  validate_rules(mtcars, "hp high" = hp < 200) |>
    action_if_problem("Here is the error", "stop")
})


validate_rules(mtcars, "hp high" = hp < 200) |>
  action_if_problem("Here is the warning", "warning")
```


### tests

```{r tests-action_if_problem}
test_that("It's produting the error",{
  
  ## The error is working
  expect_error({
      validate_rules(mtcars, 
                     "hp high" = hp < 200,
                     mpg_numeric = is.double(mpg)) |>
      action_if_problem("Here is the error", "stop")
  },
  regexp = "Here is the error",
  fixed = TRUE)
  
  
  ## The error is working
  expect_no_error({
      validate_rules(mtcars, 
                     "hp high" = is.double(hp),
                     mpg_numeric = is.double(mpg)) |>
      action_if_problem("Here is the error", "stop")
  })
  
})


test_that("It's produting the warning",{
  
  ## Shows warning
  expect_warning({
    result =
      validate_rules(mtcars, 
                     "hp high" = hp < 200,
                     mpg_numeric = is.double(mpg)) |>
      action_if_problem("Here is the warning", "warning")
  },
  regexp = "Here is the warning",
  fixed = TRUE)
  
  
  ## Not show warning
  expect_no_warning({
      validate_rules(mtcars, 
                     "hp high" = is.double(hp),
                     mpg_numeric = is.double(mpg)) |>
      action_if_problem("Here is the warning", "warning")
  })
  
  
  ## It's reporting the original object
  expect_equal(names(result), c("summary", "row_level_errors"))
  
})
```


# Inflate file

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_functions.Rmd", 
               vignette_name = NA,
               check = FALSE,
               overwrite = "yes")
```
